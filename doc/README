
* Memory Usage:

              ┃                                    ┃
              ┃                                    ┃
              ┃                                    ┃
              ┃                 ...                ┃ More User Procs
              ┃                                    ┃
              ┣━━━━━━━━━━━━━━━━━━┫
              ┃■■■■■■■■■■■■■■■■■■┃
      B00000h ┃■■■■■■■UserProc■■■■■■■┃ User Proc (e.g. shell@tty2)
              ┣━━━━━━━━━━━━━━━━━━┫
              ┃■■■■■■■■■■■■■■■■■■┃
      A00000h ┃■■■■■■■UserProc■■■■■■■┃ User Proc (e.g. shell@tty1)
              ┣━━━━━━━━━━━━━━━━━━┫
              ┃■■■■■■■■■■■■■■■■■■┃
      900000h ┃■■■■■■■■■■■■■■■■■■┃ logdiskbuf (1MB)
              ┣━━━━━━━━━━━━━━━━━━┫
              ┃■■■■■■■■■■■■■■■■■■┃
      800000h ┃■■■■■■■■■■■■■■■■■■┃ logbuf     (1MB)
              ┣━━━━━━━━━━━━━━━━━━┫
              ┃■■■■■■■■■■■■■■■■■■┃
      700000h ┃■■■■■■■■■■■■■■■■■■┃ mmbuf      (1MB)
              ┣━━━━━━━━━━━━━━━━━━┫
              ┃■■■■■■■■■■■■■■■■■■┃
      600000h ┃■■■■■■■■■■■■■■■■■■┃ fsbuf      (1MB)
              ┣━━━━━━━━━━━━━━━━━━┫
              ┃                                    ┃
              ┃                 ...                ┃ Not Used   (≈1MB)
      501000h ┃                                    ┃
              ┣━━━━━━━━━━━━━━━━━━┫
      500FFFh ┃■■■■■■■■■■■■■■■■■■┃  4GB ram needs 4MB  for page tables: [101000h, 501000h)
              ┃■■■■■■■■■■■■■■■■■■┃
              ┃■■■■■■■■■■■■■■■■■■┃
              ┃■■■■■■■■■■■■■■■■■■┃
              ┃■■■■■■■■■■■■■■■■■■┃
              ┃■■■■■■■■■■■■■■■■■■┃
              ┃■■■■■■■■■■■■■■■■■■┃
              ┣■■■■■■■■■■■■■■■■■■┫
      108FFFh ┃■■■■■■■■■■■■■■■■■■┃ 32MB ram needs 32KB for page tables: [101000h, 109000h)
              ┃■■■■■■■■■■■■■■■■■■┃
              ┃■■■■■■Page  Tables■■■■■■┃
              ┃■■■■■(大小由LOADER决定)■■■■┃ PAGE_TBL_BASE
      101000h ┣━━━━━━━━━━━━━━━━━━┫
              ┃■■■■Page Directory Table■■■■┃ PAGE_DIR_BASE = 1M
      100000h ┣━━━━━━━━━━━━━━━━━━┫
              ┃□□□□□□□□□□□□□□□□□□┃
       F0000h ┃□□□□□□□System ROM□□□□□□┃
              ┣━━━━━━━━━━━━━━━━━━┫
              ┃□□□□□□□□□□□□□□□□□□┃
       E0000h ┃□□□□Expansion of system ROM □□┃
              ┣━━━━━━━━━━━━━━━━━━┫
              ┃□□□□□□□□□□□□□□□□□□┃
       C0000h ┃□□□Reserved for ROM expansion□□┃
              ┣━━━━━━━━━━━━━━━━━━┫
              ┃□□□□□□□□□□□□□□□□□□┃ B8000h ← gs
       A0000h ┃□□□Display adapter reserved□□□┃
              ┣━━━━━━━━━━━━━━━━━━┫
              ┃□□□□□□□□□□□□□□□□□□┃
       9FC00h ┃□□extended BIOS data area (EBDA)□┃
              ┣━━━━━━━━━━━━━━━━━━┫ ----
              ┃■■■■■■■■■■■■■■■■■■┃  ↑63KB
              ┃■■■■■■■LOADER.BIN■■■■■■┃  ↓
       90000h ┣━━━━━━━━━━━━━━━━━━┫ ----
              ┃■■■■■■■■■■■■■■■■■■┃  ↑
              ┃■■■■■■■■■■■■■■■■■■┃  ∣128KB
              ┃■■■■■■■KERNEL.BIN■■■■■■┃  ↓
       70000h ┣━━━━━━━━━━━━━━━━━━┫ ----
              ┃■■■■■■■■■■■■■■■■■■┃
              ┃■■■■■■■■■■■■■■■■■■┃
              ┃■■■■■■■■■■■■■■■■■■┃
              ┃■■■■■■■■■■■■■■■■■■┃ 7C00h~7DFFh : BOOT SECTOR, overwritten by the kernel
              ┃■■■■■■■■■■■■■■■■■■┃
              ┃■■■■■■■■■■■■■■■■■■┃
        1000h ┃■■■■■■■■KERNEL■■■■■■■┃ 1000h ← KERNEL 入口 (KRNL_ENT_PT_PHY_ADDR)
              ┣━━━━━━━━━━━━━━━━━━┫
         900h ┃Boot Params                         ┃
              ┃                                    ┃
         500h ┃              F  R  E  E            ┃
              ┣━━━━━━━━━━━━━━━━━━┫
              ┃□□□□□□□□□□□□□□□□□□┃
         400h ┃□□□□ROM BIOS parameter area □□┃
              ┣━━━━━━━━━━━━━━━━━━┫
              ┃◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇┃
           0h ┃◇◇◇◇◇◇Int  Vectors◇◇◇◇◇◇┃
              ┗━━━━━━━━━━━━━━━━━━┛ ← cs, ds, es, fs, ss

**	1. 内核最大不能超过 128KB （96KB @ 2008.12.11）。如果超过，则需
	   - 修改 load.inc 中的 KERNEL_FILE_SEG，比如修改为 50000h
	   - KERNEL_FILE_SEG 修改后势必积压 kernel 的空间，解决方案见下文

**	2. 内核展开后，最高处的段不能超过 70000h （41C44h @ 2008.12.11）。如果超过，则需
	   - 修改 proc.h 中的 STACK_SIZE_DEFAULT，将其改小（Minix中任务堆栈都很小，基本小于512字节），
	     如果此法可行，则问题解决，若不可行，进行下面各步骤
	   - 修改 load.inc 中的 KRNL_ENT_PT_PHY_ADDR，并且
	   - 修改 MAKEFILE 中参数 -Ttext 的值
	     （比如，如果把 KRNL_ENT_PT_PHY_ADDR 和 -Ttext 的值都改为 0x400400，则 KERNEL 就会被加载到内存 0x400000(4M) 处，入口在 0x400400。）
	   - 做上述修改同时影响到的还有Init进程。假设内核入口在 0x400400 处，则其最高处肯定大于 0x400400，我们假设其到达 5MB 处，于是
	     Init进程的地址空间为 [0, 5MB]。当Init进程fork出子进程P时，MM会试图将 [0, 5MB] 的内存全部拷贝给P。这就造成：
	          i. 很大的浪费──因为 [0, 4MB] 的内容是无用的
		 ii. 异常出现，系统崩溃──因为我们设定每个进程最多使用 1MB 内存
	     解决的办法有两种：
	         (1) 无论何时也不把 kernel 挪出最低的内存区域
		 (2) 修改Init进程的实现方式，让它不要直接使用 [0, 5MB] 这样的空间作为自己的内存区域（这应该不会太难）

**	3. 关于页表（page table）
	   - 如果内存有 4GB 的话，那么页表将占据 [101000h, 501000h) 共计 4MB 的内存空间。[501000h, 600000h) 这段约 1MB 的空间为浪费状态。
	   - 如果内存比较小，比如只有 32MB，那么页表只占 [101000h, 109000h) 共计 32KB 的空间，那么 [109000h, 600000h) 共 4.9MB 多的空间是空闲的。

**	4. 关于缓冲区
	   - 目前有四块缓冲区是直接用的系统内存──而不是使用数组声明从而占用 kernel 的 .bss 段空间，它们定义在 globle.c 中，分别是：
	     fsbuf, mmbuf, logbuf, logdiskbuf

* GDT:

		              Descriptors               Selectors
              ┏━━━━━━━━━━━━━━━━━━┓
              ┃                                    ┃
                                ...
              ┃                                    ┃
              ┣━━━━━━━━━━━━━━━━━━┫
              ┃         DESC_LDT_for_TestC         ┃
              ┣━━━━━━━━━━━━━━━━━━┫
              ┃         DESC_LDT_for_TestB         ┃
              ┣━━━━━━━━━━━━━━━━━━┫
              ┃         DESC_LDT_for_TestA         ┃
              ┣━━━━━━━━━━━━━━━━━━┫
              ┃         DESC_LDT_for_INIT          ┃
              ┣━━━━━━━━━━━━━━━━━━┫
              ┃         DESC_LDT_for_MM            ┃
              ┣━━━━━━━━━━━━━━━━━━┫
              ┃         DESC_LDT_for_FS            ┃
              ┣━━━━━━━━━━━━━━━━━━┫
              ┃         DESC_LDT_for_SYS           ┃
              ┣━━━━━━━━━━━━━━━━━━┫
              ┃         DESC_LDT_for_TTY           ┃
              ┣━━━━━━━━━━━━━━━━━━┫
              ┃         DESC_TSS                   ┃
              ┣━━━━━━━━━━━━━━━━━━┫
              ┃         DESC_VIDEO                 ┃  1Bh = gs
              ┣━━━━━━━━━━━━━━━━━━┫
              ┃         DESC_FLAT_RW   (0～4G)     ┃  10h = ds, es, fs, ss
              ┣━━━━━━━━━━━━━━━━━━┫
              ┃         DESC_FLAT_C    (0～4G)     ┃   8h = cs
              ┣━━━━━━━━━━━━━━━━━━┫
              ┃         Dummy Descriptor           ┃
              ┗━━━━━━━━━━━━━━━━━━┛

**	1. 在使用 C 代码的时候一定要保证 ds, es, ss 这几个段寄存器的值是一样的
	   因为编译器有可能编译出使用它们的代码, 而编译器默认它们是一样的. 比如串拷贝操作会用到 ds 和 es.

**	2. 由于每个进程需要用到 GDT 中的一项，而 GDT 最多 128 个描述符，所以
	   进程数 <= 123

* MM
	                                                                16                         0                                      
	                                                             H +----------------------------+                                     
	                                                               |                            |            / H +--------------------+
	          16                         0                         ~             ~              ~           |    |                    |  \
	       H +----------------------------+                        |                            |           |    |                    |  |               
	         |                            |                      / +----------------------------+           |    |       Stack        |  |- STACK_SIZE_DEFAULT
	         ~             ~              ~                     |  |                            |           |    |                    |  |
	         |                            |                     |  |                            |           |    |                    |  /
	         +----------------------------+                     |  |                           -+---.       |    >--------------------<
	         |                            |                     |  |     ldts[INDEX_LDT_RW]     |   |       |    :                    :
	         |                            |               .--->-|  +----------------------------+   |       |    >--------------------<
	         |                            |              /      |  |                            |   +----->-|    |                    |
	         |     ldt desc for proc j    |             /       |  |                            |   |  ③   |    |                    |
	         +----------------------------+            /        |  |                           -+---`       |    |       Data         |
	         |                            |           /         |  |     ldts[INDEX_LDT_C]      |           |    |                    |
	         ~             ~              ~          /           \ +----------------------------+           |    |                    |
	         |                            |         /              |     ldt_sel               -+--.        |    >--------------------<
	         +----------------------------+        /               +----------------------------+  |        |    |                    |
	         |                            |       /                |                            |  |        |    |       Text         |
	         |                            |      /                 ~     STACK FRAME            ~  |        |    |                    |
	         |                           -+-----`                  |                            |  |         \ L +--------------------+
	 .-----> |     ldt desc for proc i    |  ①                  L +----------------------------+  |                  process image
	 |       +----------------------------+                                 proc_table[i]          |              allocated in do_fork()
	 |       |                            |                                                        |          
	 |       ~             ~              ~                                                        |           
	 |       |                            |                                                        |
	 |     L +----------------------------+                                                        |
	 |                    GDT                                                                      |
	 |                                                                                             |
	 `---------------------------------------------------------------------------------------------`
	                                        ② 
	 
	 ① initialized in protect.c:: init_descriptor(&gdt[INDEX_LDT_FIRST + i],
	                                               makelinear(SELECTOR_KERNEL_DS,
	                                                          proc_table[i].ldts),
	                                               LDT_SIZE * sizeof(DESCRIPTOR) - 1,
	                                               DA_LDT);
	 
	 ② initialized in protect.c:: proc_table[i].ldt_sel = SELECTOR_LDT_FIRST + (i << 3);
	 
	 ③ done in do_fork()
	 
	

* 硬盘次设备号命名规则

**	illustration of minor device number:

                             / drive 0:
                             | +---------------------------------------------------------------------------------------------------------------+   \
                             | |                                       hd0  ← device name           /the same\                                |   |
                             | |                                        0   ← minor device number   \ below  /                                |   | prim_dev: hd[0-5]
                             | +---------------------------------------------------------------------------------------------------------------+   |
                             | |            hd1            |            hd2            |            hd3            |            hd4            | ←--- primary partitions
                             | |             1             |             2             |             3             |             4             |   |
                             | +---------------------------+---------------------------+---------------------------+---------------------------+   /
                             | | hd1a | hd1b |  ... | hd1p | hd2a | hd2b |  ... | hd2p | hd3a | hd3b |  ... | hd3p | hd4a | hd4b |  ... | hd4p |
                             | | 0x10 | 0x11 |  ... | 0x1F | 0x20 | 0x21 |  ... | 0x2F | 0x30 | 0x31 |  ... | 0x3F | 0x40 | 0x41 |  ... | 0x4F |
                             | +---------------------------+---------------------------+---------------------------+---------------------------+
                             | |  ↑                       |←NR_SUB_PER_PARTITION:16→|                                                       |
                             | |  MINOR_hd1a:0x10          |  a, b, c, d,  e, f, g, h  |                                                       |
                             | |                           |  i, j, k, l,  m, n, o, p  |                                                       |
                             | |                                                                                                               |
                             | |←----------------------------------------- NR_PART_PER_DRIVE:  4 -------------------------------------------→|
                             | |←----------------------------------------- NR_SUB_PER_DRIVE : 64 -------------------------------------------→|
                             |                                                                                                                                            
                             |  struct hd_info::primary[0,1,2,3,4]    \
                             |                                         > the base and size of a drive/partition (in sectors)
                             |  struct hd_info::logical[0,1,2,...,63] /
                             |
	drives(MAX_DRIVES:2) |
                             |
                             |
                             | drive 1:
                             | +---------------------------------------------------------------------------------------------------------------+   \
                             | |                                                      hd5                                                      |   |
                             | |                                                       5                                                       |   | prim_dev: hd[5-9]
                             | +---------------------------------------------------------------------------------------------------------------+   |                       
                             | |             hd6           |            hd7            |            hd8            |            hd9            | ←--- primary partitions
                             | |              6            |             7             |             8             |             9             |   |
                             | +---------------------------+---------------------------+---------------------------+---------------------------+   /
                             | | hd6a | hd6b |  ... | hd6p | hd7a | hd7b |  ... | hd7p | hd8a | hd8b |  ... | hd8p | hd9a | hd9b |  ... | hd9p |
                             | | 0x50 | 0x51 |  ... | 0x5F | 0x60 | 0x61 |  ... | 0x6F | 0x70 | 0x71 |  ... | 0x7F | 0x80 | 0x81 |  ... | 0x8F |
                             \ +---------------------------+---------------------------+---------------------------+---------------------------+
                               |←----- partition 0 -----→|←----- partition 1 -----→|       ↗                  |←----- partition 3 -----→|
                                                                                             .`
                                                      .-------------------------------------`
                                                     |                                                                                                       
                                              e.g. how to calculate the minor device number of `hd8b':
                                                     hd8b: drive 1, partition 2, subpartion 1                                                             
                                                     device_number = MINOR_hd1a + NR_SUB_PER_DRIVE * drive + NR_SUB_PER_PARTITION * partition + subpartition       
                                                                   = 0x10       +             0x40 * drive +                 0x10 * partition + subpartition       
                                                                   = 0x10       +             0x40 * 1     +                 0x10 * 2         + 1                  
                                                                   = 0x10       +             0x40         +                 0x20             + 1                  
                                                                   = 0x71                                                                                    
                                              (drive, partion, subpartion : zero-based)

**	脚本 scripts/hdgeo 可列出一个磁盘所有的分区，并给出每个分区的次设备号

* Hard Disk (9D41h sectors, 19.7MB):

   sector nr.
          ↓
              ┃                                    ┃
              ┃                 ...                ┃
              ┃                                    ┃
        9D41h ┃                                    ┃
              ┗━━━━━━━━━━━━━━━━━━┛
              ┏━━━━━━━━━━━━━━━━━━┓← The End of the Partition
              ┃◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇┃
        9541h ┃◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇┃ disklog zone (800h sectors, 1MB)
              ┣━━━━━━━━━━━━━━━━━━┫ --------------
              ┃                                    ┃            ↑
              ┃       unable to be allocated       ┃            ∣≈1.5MB
        8800h ┃                                    ┃            ↓
              ┣━━━━━━━━━━━━━━━━━━┫ --------------
              ┃◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇┃
        8000h ┃◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇┃ cmd.tar (16MB from the beginning of the partition)
              ┣━━━━━━━━━━━━━━━━━━┫ --------------
              ┃                                    ┃            ↑
              ┃       unable to be allocated       ┃            ∣6F3h sectors, ≈900KB
        790Dh ┃                                    ┃            ↓
              ┣━━━━━━━━━━━━━━━━━━┫ --------------
              ┃◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇┃            ↑
        710Dh ┃◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇┃ File 14    ∣
              ┣━━━━━━━━━━━━━━━━━━┫            ∣
              ┃                                    ┃            ∣
                                ...                               ∣≈15MB for regular files
              ┃                                    ┃            ∣
              ┣━━━━━━━━━━━━━━━━━━┫            ∣
              ┃◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇┃            ∣
        110Dh ┃◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇┃ File  2    ∣
              ┣━━━━━━━━━━━━━━━━━━┫            ∣
              ┃◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇┃            ∣
         90Dh ┃◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇┃ File  1    ↓
              ┣━━━━━━━━━━━━━━━━━━┫ --------------
              ┃◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇┃
         10Dh ┃◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇┃ ROOT Dir (size: 800h sectors, 1MB)
              ┣━━━━━━━━━━━━━━━━━━┫
              ┃◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇┃
           Dh ┃◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇┃ inodes (4096*32/512=256 sectors)
              ┣━━━━━━━━━━━━━━━━━━┫
           Ch ┃◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇┃     19MB HD needs Ah sectors for smap
              ┃◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇┃
           3h ┃◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇┃ sector map (disksize_in_sect/4096+1 sectors)
              ┣━━━━━━━━━━━━━━━━━━┫
           2h ┃◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇┃ inode map
              ┣━━━━━━━━━━━━━━━━━━┫
           1h ┃◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇┃ super block
              ┣━━━━━━━━━━━━━━━━━━┫
           0h ┃◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇┃ boot sector
              ┣━━━━━━━━━━━━━━━━━━┫
              ┃                                    ┃
              ┃                 ...                ┃
              ┃                                    ┃
		

**	1. 上图是一个极小硬盘分区的例子。这个分区有 9D41h 个扇区，合计约 19.7MB。

**	2. sector map 占用的扇区数取决于硬盘分区的大小：

	              ┃◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇┃ inodes
	              ┣━━━━━━━━━━━━━━━━━━┫
	      (C803h) ┃◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇┃		100GB HD needs C801h sectors for smap
	              ┣◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇┫
	      (6403h) ┃◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇┃		 50GB HD needs 6401h sectors for smap
	              ┣◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇┫
	      (1403h) ┃◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇┃		 10GB HD needs 1401h sectors for smap
	              ┣◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇┫
	       (203h) ┃◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇┃ 		 1GB HD needs  201h sectors for smap
	              ┣◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇┫
	        (34h) ┃◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇┃		100MB HD needs   32h sectors for smap
	              ┣◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇┫
	           Ch ┃◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇┃		 19MB HD needs    Ah sectors for smap
	              ┃◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇┃
	           3h ┃◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇┃ sector map (disksize_in_sect/4096+1 sectors)
	              ┣━━━━━━━━━━━━━━━━━━┫

**	3. 关于 cmd.tar
		- 占用分区 [8000h, 8800h)，共计 1MB
		- 问题
			* 分区 [790Dh, 8000h) 无法被 FS 使用，因为它不足 1MB。
			  如果已经有了 14 个 regular file，继续调用 open() 来创建文件，则
			  会触发 alloc_smap_bit() 中的 assert:
			  	assert(((fsbuf[j] >> k) & 1) == 0);
			* 分区 [8800h, 9541h) 也无法被 FS 使用，除非：
			  在 smap 中将分区 [790Dh, 8000h) 标记为已分配。
			  这样下次调用 alloc_smap_bit() 时，[8800h, 9000h) 这 1MB 的空间仍可供一个文件所用。
		- 如果在较大的硬盘上安装 Orange'S，应该：
		  将 cmd.tar 放在尽量靠近分区结束的位置，只要修改 config.h 中的 INSTALL_START_SECT 即可。
		- 修改 INSTALL_START_SECT 时一定要保证 cmd.tar 不会和 disklog 冲突

* Orange'S v0.02 总结
**	0. 系统
		Orange'S Partition sys-id	0x99			（SEE: const.h）
		disklog 放在哪里		分区的最后 1MB 磁盘空间
		cmd.tar 放在哪里		扇区 [8000h, 8800h)	（SEE: config.h::INSTALL_START_SECT）
		BOOT PARAM 放在哪里		0x900			（SEE: config.h::BOOT_PARAM_ADDR）
		哪个分区为根分区		MINOR_BOOT		（SEE: config.h）
		系统调用使用的软中断号		0x90			（SEE: protect.h::INT_VECTOR_SYS_CALL）

**	1. 各种限制
		系统任务数			＝ 5	（TTY, SYS, HD, FS, MM）
		进程数				≤ 123	（包括系统任务；
							  SEE: proc.h::NR_PROCS
							  SEE: 前文 GDT 节
							  进程数还受内存大小制约，如果内存为32MB，由于用户进程内存从10MB开始，所以最多有32-10=12个进程
							 ）
		系统任务的堆栈大小		＝ 16KB	（TTY, SYS, HD, FS, MM
							  SEE: proc.h::STACK_SIZE_DEFAULT
							 ）
		INIT和Test[ABC]任务的堆栈大小	＝ 16KB	（Init, TestA, TestB, TestC
							  SEE: proc.h::STACK_SIZE_DEFAULT
							 ）
		用户进程的堆栈大小		＜ 1MB	（进程内存空间总共 1MB
							  除去代码和数据，剩下的就是堆栈可用的
							 ）
		每个进程可打开的文件数		≤ 64	（SEE: const.h::NR_FILES
							  SEE: proc.h::struct proc
							 ）
		系统内能打开多少个i- node	≤ 64	（SEE: const.h::NR_INODE
							  SEE: global.h::i_node_table
							 ）
		系统内能打开多少个文件描述符	≤ 64	（SEE: const.h::NR_FILE_DESC
							  SEE: global.h::f_desc_table
							 ）
		从内存何处开始可以为用户进程所用＝ 10MB	（SEE: proc.h::PROC_BASE）
		进程使用内存数			≤ 1MB	（SEE: proc.h::PROC_IMAGE_SIZE_DEFAULT）
		进程运行前MM为其准备的堆栈大小	≤ 1KB	（为 argc 和 argv 所用；
							  SEE: proc.h::PROC_ORIGIN_STACK
							 ）
		是否支持 IDE0 (primary)		是
		是否支持 IDE1 (secondary)	否
		支持几块硬盘			≤ 2	（IDE0 上的主盘和从盘）
		每个扩展分区可有几个逻辑分区	≤ 16

**	2. 若换一个硬盘（映像），则须改动：
		boot/include/load.inc::ROOT_BASE	← Orange'S 分区的首扇区的扇区号（相对于整个磁盘开始）
		include/sys/config.h::MINOR_BOOT	← Orange'S 分区的次设备号
		Makefile::HD				← 新硬盘（映像）文件名
		commands/Makefile::HD			← 新硬盘（映像）文件名 
		bochsrc::ata0-master			← 如果使用映像文件的话

**	3. 安装到硬盘 / 从硬盘启动
		准备：
			一张软盘。软盘无论如何都用得到，它用来：
				 i. mkfs()
				ii. 解开 cmd.tar，里面存有 hdldr.bin 和 kernel.bin
		操作：
			 1. 使用自写工具 hdgeo 查看硬盘的分区情况，确定要装到哪个分区，记下下列内容：
				分区的首扇区扇区号
				分区的首扇区字节偏移（用于调试）
				分区的次设备号
			 2. 确认以下设置的正确性（另见相关章节）
				boot/include/load.inc::ROOT_BASE	← Orange'S 分区的首扇区的扇区号（相对于整个磁盘开始）
				include/sys/config.h::MINOR_BOOT	← Orange'S 分区的次设备号
				Makefile::HD				← 新硬盘（映像）文件名
				commands/Makefile::HD			← 新硬盘（映像）文件名 
				bochsrc::ata0-master			← 如果使用映像文件的话
			 3. 修改 INSTALL_START_SECT （config.h） ，使之尽量靠近分区的底部
			 4. 用 Makefile
				将软盘做成启动盘（写入 boot.bin, loader.bin 和 kernel.bin），并且
				将 hdboot.bin 写入硬盘相应分区（由 ROOT_BASE 决定）
			 5. 用 commands/Makefile
				将 hdldr.bin 和 kernel.bin 打入 cmd.tar 包中，然后
				将 cmd.tar 写入硬盘（注意位置一定要再三确认，以免破坏硬盘中已有的数据）
			 6. 如果是个空硬盘的话，需要安装 grub （使用自写脚本grubinst）:
				scripts/grubinst HD_FILE /usr/local/src/grub-0.97/stage1/stage1 /usr/local/src/grub-0.97/stage2/stage2
			 7. 从软盘启动
				这时 Orange'S 会通过 fs/main.c::mkfs() 将硬盘的相应分区做成 Orange'S FS，并且
				将 cmd.tar 解开，这时 FS 中就有 hdldr.bin 和 kernel.bin 了
			 8. 通过命令 ls 确认是否 hdldr.bin 和 kernel.bin 已经存在
			 9. 从硬盘启动，待出现 grub 提示符时，依次输入：
				grub> rootnoverify (hd0,4)
				grub> chainloader +1
				grub> boot
			10. 启动成功

* 文件操作与Linux的不同

	在 Orange'S 和 Linux 中分别调用 open() 和 write() 函数：
		Orange'S 中
			open(filename, flags);
		Linux 中
			open(filename, flags, 0644);
	得到以下异同：

	 open() 
	 	O_CREAT  O_RDWR  O_TRUNC   |	file doesn't exists		file exists		 
	 	---------------------------|------------------------------------------------------------------------------------------- 
	 1	   *			   |	OK				return -1 (Linux中OK)
	 	---------------------------|------------------------------------------------------------------------------------------- 
	 2	            *		   |	return -1			open it 
	 	---------------------------|------------------------------------------------------------------------------------------- 
	 3	                    *	   |	return -1			return -1 (Linux中OK)
	 	---------------------------|------------------------------------------------------------------------------------------- 
	 4	   *        *		   |	OK				return -1 (Linux中OK)
	 	---------------------------|------------------------------------------------------------------------------------------- 
	 5	   *                *	   |	OK				return -1 (Linux中OK)
	 	---------------------------|------------------------------------------------------------------------------------------- 
	 6	            *       *	   |	return -1			open it & truncate it 
	 	---------------------------|------------------------------------------------------------------------------------------- 
	 7	   *        *       *	   |	OK				open it & truncate it 
	 	---------------------------|------------------------------------------------------------------------------------------- 


	 write() 
	 	O_CREAT  O_RDWR  O_TRUNC   |	file doesn't exists		file exists		 
	 	---------------------------|---------------------------------------------------------------- 
	 1	   *			   |	No				-- 
	 	---------------------------|---------------------------------------------------------------- 
	 2	            *		   |	--				Yes 
	 	---------------------------|---------------------------------------------------------------- 
	 3	                    *	   |	--				-- 
	 	---------------------------|---------------------------------------------------------------- 
	 4	   *        *		   |	Yes				-- (Linux中OK)
	 	---------------------------|---------------------------------------------------------------- 
	 5	   *                *	   |	No				-- 
	 	---------------------------|---------------------------------------------------------------- 
	 6	            *       *	   |	--				Yes 
	 	---------------------------|---------------------------------------------------------------- 
	 7	   *        *       *	   |	Yes				Yes 
	 	---------------------------|---------------------------------------------------------------- 

* BUGs
	[2008.12.16]
		- 疑似 out_char() BUG
		- untar() 中打印出 kernel.bin 的文件名之后，屏幕突然一片混乱
		- 在 bochs 中很正常，但在真实机器中偶尔会出现此问题
		- 现象不容易重现
